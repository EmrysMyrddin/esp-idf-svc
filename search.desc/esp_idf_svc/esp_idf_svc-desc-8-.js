searchState.loadedDescShard("esp_idf_svc", 8, "Emitted when Wi-Fi AP credentials are received via …\nEmitted when device successfully connects to the AP of …\nSignals that manager has been de-initialized\nSignals that provisioning service has stopped\nEmitted when the manager is initialized\nIndicates that provisioning has started\n@brief   Handler for receiving and responding to requests …\n@brief   WiFi status data to be sent in response to …\n@brief   Internal handlers for receiving and responding to …\n@brief   Internal handlers for receiving and responding to …\n@brief   WiFi config data received by slave during …\n@brief   Type of context data passed to each get/set/apply …\n@brief   Event handler that is used by the manager while …\n@brief   Structure for specifying the manager configuration\n@brief   Runs Wi-Fi as Station with the supplied …\n@brief   Stop provisioning (if running) and release …\n@brief   Disable auto stopping of provisioning service …\n@brief   Create an additional endpoint and allocate …\n@brief   Register a handler for the previously created …\n@brief   Unregister the handler for an endpoint\n@brief   Get reason code in case of Wi-Fi station …\n@brief   Get state of Wi-Fi Station during provisioning\n@brief   Initialize provisioning manager instance\n@brief   Checks if device is provisioned\n@brief   Reset Wi-Fi provisioning config\n@brief   Reset internal state machine and clear …\n@brief   Reset internal state machine and clear …\n@brief   Set application version and capabilities in the …\n@brief   Start provisioning service\n@brief   Stop provisioning service\n@brief   Wait for provisioning service to finish\n@brief   Structure for specifying the provisioning scheme …\n@brief   Scheme that can be used by manager for …\n@brief   Set manufacturer specific data in scan response\n@brief   Set the 128 bit GATT service UUID used for …\n@brief   Scheme that can be used by manager for …\n@brief Provide HTTPD Server handle externally.\n@brief   Structure for specifying the provisioning scheme …\n@brief   Security modes supported by the Provisioning …\n@brief  Security 1 params structure This needs to be …\n@brief  Security 2 params structure This needs to be …\nNo security (plain-text communication)\nThis secure communication mode consists of X25519 key …\nThis secure communication mode consists of SRP6a based …\n@brief   Security modes supported by the Provisioning …\n@brief   WiFi STA connected status information\n@brief   WiFi STA connection fail reason\n@brief   WiFi STA status for conveying back to the …\n&lt; Maximum modem power saving. In this mode, interval to …\n&lt; Minimum modem power saving. In this mode, station wakes …\n&lt; No power save\n@brief     Reallocate a chunk of memory for WiFi driver\n@brief     The WiFi RX callback function\nConfiguration for SAE-PK\nConfiguration for SAE PWE derivation\n@brief Parameters for an SSID scan.\n&lt; All channel scan, scan will end after scan all the …\n&lt; Do fast scan, scan will end after find SSID match AP\n@brief Structure describing parameters for a WiFi fast scan\n@brief Aggregate of active &amp; passive scan time per channel\n&lt; active scan\n&lt; passive scan\n&lt; the channel width is HT40 and the secondary channel is …\n&lt; the channel width is HT40 and the secondary channel is …\n&lt; the channel width is HT20\n&lt; Sort match AP in scan list by security mode\n&lt; Sort match AP in scan list by RSSI\n@brief STA configuration settings for the device\n@brief Description of STA associated with AP\n@brief List of stations associated with the Soft-AP\n&lt; WiFi state of the station\n&lt; all configuration will store in both memory and flash\n&lt; all configuration will only store in the memory\n&lt; WiFi Task Core ID\n@brief    TxDone callback function type. Should be …\n@brief     Vendor Information Element index\n@brief     Vendor Information Element type\n@brief Erase part of the WL storage\n@brief wear levelling handle\n@brief Mount WL for defined partition\n&lt; The value is ESP_BLE_WHITELIST_ADD if add address to …\n@brief Read data from the WL storage\n@brief Get sector size of the WL instance\n@brief Get the actual flash size in use for the WL storage …\n@brief Unmount WL for defined partition\n@brief Write data to the WL storage\n@brief   LWIP’s network stack init function for WiFi (AP)\n@brief   LWIP’s network stack init function for WiFi …\n@brief   LWIP’s network stack init function for WiFi …\n@brief   LWIP’s network stack input packet function for …\n&lt; WP pin when SPI pins set via efuse (read by ROM …\n&lt; WiFi station crypto functions when connect\n@brief The crypto callback function structure used by …\n@brief Structure representing WPS factory information for …\n&lt; WPS failed during auth\n&lt; WPS failed due to incorrect config\n&lt; WPS normal fail reason\n@brief Enumeration of WPS (Wi-Fi Protected Setup) types.\n&lt; The type of WPS to be used (PBC or PIN).\n&lt; WPS is disabled\n&lt; Maximum value for WPS type enumeration\n&lt; WPS Push Button Configuration method\n&lt; WPS PIN (Personal Identification Number) method\n@brief Enumeration of WPS (Wi-Fi Protected Setup) types.\n@brief Custom driver SPI write\n&lt; Write without context pointer\n&lt; sector write function\n&lt; Gatt client callback param of ESP_GATTC_WRITE_DESCR_EVT\n&lt; Gatt server callback param of ESP_GATTS_WRITE_EVT\nSlicer for write data. The <code>program_page</code> should be called …\nSlicer for write data. The <code>program_page</code> should be called …\n&lt; The write file descriptors\n&lt; Write with context pointer\n@brief Write PHY register\n@brief Write PHY register\n@brief Write PHY register\n&lt; WS pin, input in slave role, output in master role\n&lt; WS pin, input in slave role, output in master role\n&lt; WS pin, input in slave role, output in master role\n&lt; HTTP path to update protocol to websocket\n&lt; WS signal polarity, set true to enable high lever first\n&lt; WS signal polarity, set true to enable high lever first\n&lt; not a valid opcode to indicate no message previously …\n&lt; WS signal width (i.e. the number of BCLK ticks that WS …\n&lt; WS signal width (i.e. the number of BCLK ticks that WS …\n@cond\n@cond\nClear bits within an event group.  This function cannot be …\n@brief Creates an event group with specific memory …\nA version of xEventGroupGetBits() that can be called from …\nSet bits within an event group. This function cannot be …\nAtomically set bits within an event group, then wait for a …\n[Potentially] block to wait for one or more bits to be set …\n&lt; The handle of the task to which the rest of the …\n&lt; The handle of the task to which the rest of the …\n@brief Checks if a given piece of memory can be used to …\n@brief Checks if a given piece of memory can be used to …\n@brief Get the tick rate per second\n@brief Checks if the current core is in an ISR context\n@brief Check if in ISR context from High priority ISRs\n@brief Disable interrupts in a nested manner (meant to be …\n@brief Checks if a given piece of memory can be used to …\nAdds a queue or semaphore to a queue set that was …\n@cond !DOC_EXCLUDE_HEADER_SECTION\nQueue sets provide a mechanism to allow a task to block …\n@brief Creates a queue with specific memory capabilities\nIt is preferred that the macros xQueueSend(), …\nIt is preferred that the macros xQueueSendFromISR(), …\nQueries a queue to determine if the queue is empty. This …\nQueries a queue to determine if the queue is full. This …\nReceive an item from a queue without removing the item …\nA version of xQueuePeek() that can be called from an …\nReceive an item from a queue.  The item is received by …\nReceive an item from a queue.  It is safe to use this …\nRemoves a queue or semaphore from a queue set.  A queue or …\nxQueueSelectFromSet() selects from the members of a queue …\nA version of xQueueSelectFromSet() that can be used from …\n@brief   Add the ring buffer to a queue set. Notified when …\n@brief       Create a ring buffer\n@brief Create a ring buffer of type RINGBUF_TYPE_NOSPLIT …\n@brief       Create a ring buffer but manually provide the …\n@brief Creates a ring buffer with specific memory …\n@brief   Get current free size available for an item/data …\n@brief   Get maximum size of an item that can be placed in …\n@brief Retrieve the pointers to a statically created ring …\n@brief   Debugging function to print the internal pointers …\n@brief   Retrieve an item from the ring buffer\n@brief   Retrieve an item from the ring buffer in an ISR\n@brief   Retrieve a split item from an allow-split ring …\n@brief   Retrieve a split item from an allow-split ring …\n@brief   Retrieve bytes from a byte buffer, specifying the …\n@brief   Retrieve bytes from a byte buffer, specifying the …\n@brief   Remove the ring buffer from a queue set\n@brief       Insert an item into the ring buffer\n@brief Acquire memory from the ring buffer to be written …\n@brief       Actually send an item into the ring buffer …\n@brief       Insert an item into the ring buffer in an ISR\n@brief Struct that is equivalent in size to the ring buffer…\n@cond\nQueries a stream buffer to see how much data it contains, …\n@cond !DOC_EXCLUDE_HEADER_SECTION\n@cond\nQueries a stream buffer to see if it is empty.  A stream …\nQueries a stream buffer to see if it is full.  A stream …\nReceives bytes from a stream buffer.\nFor advanced users only.\nAn interrupt safe version of the API function that …\nResets a stream buffer to its initial, empty, state.  Any …\nSends bytes to a stream buffer.  The bytes are copied into …\nFor advanced users only.\nInterrupt safe version of the API function that sends a …\nA stream buffer’s trigger level is the number of bytes …\nQueries a stream buffer to see how much free space it …\n@brief Task Snapshot structure\nUsed with the uxTaskGetSystemState() function to return …\n@cond !DOC_EXCLUDE_HEADER_SECTION\nINCLUDE_xTaskAbortDelay must be defined as 1 in …\nCalls the hook function associated with xTask.  Passing …\nThis function corrects the tick count value after the …\nDetermines if pxTicksToWait ticks has passed since a time …\n@brief Create a new task that is pinned to a particular …\n@brief Creates a pinned task where its stack has specific …\n@brief Create a new static task that is pinned to a …\nINCLUDE_xTaskDelayUntil must be defined as 1 for this …\nSee https://www.FreeRTOS.org/RTOS-task-notifications.html …\nSee https://www.FreeRTOS.org/RTOS-task-notifications.html …\nSee https://www.FreeRTOS.org/RTOS-task-notifications.html …\nWaits for a direct to task notification to be pending at a …\n@brief Get the current core ID of a particular task\n@brief Get the handle of the task currently running on a …\nNOTE:  This function takes a relatively long time to …\nxTaskGetIdleTaskHandle() is only available if …\n@brief Get the handle of idle task for the given core.\n@brief Get the next task using the task iterator.\n@return The count of ticks since vTaskStartScheduler was …\n@return The count of ticks since vTaskStartScheduler was …\n@cond !DOC_EXCLUDE_HEADER_SECTION\n&lt; A number unique to the task.\n&lt; A number unique to the task.\nResumes scheduler activity after it was suspended by a …\nINCLUDE_xTaskResumeFromISR must be defined as 1 for this …\n@cond !DOC_EXCLUDE_HEADER_SECTION\nReturns the time in ticks at which the timer will expire.  …\nReturns the period of a timer.\nQueries a timer to determine if it is an auto-reload …\nSimply returns the handle of the timer service/daemon …\nQueries a timer to see if it is active or dormant.\nUsed to defer the execution of a function to the RTOS …\nUsed from application interrupt service routines to defer …\n&lt; Xoff flow control char\n&lt; If the software flow control is enabled and the data …\n&lt; Xon flow control char\n&lt; If the software flow control is enabled and the data …\n&lt; Date.\nYield to other tasks. Called during erase operations.\n&lt; zone ID\n&lt; zone ID\nBuild time in the local timescale.\nBuild time in UTC.\nCamel case, eg: <code>fooBarBaz</code>. The first character is always …\nThe casing style of a string.\nKebab case, eg: <code>foo-bar-baz</code>. Also turns the string …\nLowercase\nWrapper for many std types, which implements the …\nPascal case, eg: <code>FooBarBaz</code>. The first character is always …\nSnake case, eg: <code>foo_bar_baz</code>. Also turns the string …\nThe return value of <code>str_splice</code>\nUppercase\nKebab case, eg: <code>FOO-BAR-BAZ</code>. Also turns the string …\nSnake case, eg: <code>FOO_BAR_BAZ</code>. Also turns the string …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how much space is necessary to write the wrapped …\nComputes how much space is necessary to write …\nConcatenates constants of primitive types into a …\nFormats constants of primitive types into a <code>&amp;&#39;static str</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the casing style of a <code>&amp;&#39;static str</code> constant, …\nA string that had <code>removed</code> replaced with some other string.\nThe part of the string that was removed.\nFor constructing from a reference to an array.\nIndexes a <code>&amp;&#39;static str</code> constant, returning <code>None</code> when the …\nIndexes a <code>&amp;&#39;static str</code> constant.\nCreates a <code>&amp;&#39;static str</code> by repeating a <code>&amp;&#39;static str</code> …\nReplaces all the instances of <code>$pattern</code> in <code>$input</code> (a …\nReplaces a substring in a <code>&amp;&#39;static str</code> constant. Returns …\nAlternative version of <code>str_splice</code> which only returns the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer.\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nClient for the ESP system time\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn the current system time\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSame as <code>timer_async</code> but does not wake the device from …\nSafety\nSafety\nSame as <code>timer</code> but does not wake the device from light …\nWrapper for <code>esp-tls</code> module. Only supports synchronous …\nCreate a new <code>EspTls</code> instance adopting the supplied socket. …\nCreate a new <code>AsyncEspTls</code> instance adopting the supplied …\nup to 9 ALPNs allowed, with avg 10 bytes for each name\nEstablish a TLS/SSL connection with the specified host and …\nKeep-alive packet retry send count\nEnable keep-alive timeout\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the integer FD.\nKeep-alive idle time (second)\nKeep-alive interval time (second)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEstablish a TLS/SSL connection using the adopted socket.\nEstablish a TLS/SSL connection using the adopted socket.\nCreate a new <code>EspTls</code> instance using internally-managed …\nRead in the supplied buffer. Returns the number of bytes …\nRead in the supplied buffer. Returns the number of bytes …\nThis is called before cleaning up the the tls context and …\nwhether to use esp_crt_bundle_attach, see …\nWrite the supplied buffer. Returns the number of bytes …\nWrite the supplied buffer. Returns the number of bytes …\nWraps a <code>WifiDriver</code> or <code>EspWifi</code>, and offers strictly <code>async</code> …\nWraps a <code>WifiDriver</code> or <code>EspWifi</code>, and offers strictly …\nAdvertize PMF support and wether PMF is required or not\nConfiguration for wifi in STA mode\nScan every channel and connect according to ScanSortMethod …\n<code>EspWifi</code> wraps a <code>WifiDriver</code> Data Link layer instance, and …\nConnect to the first found AP and stop scanning\nNo support for PMF will be advertized (default)\nProtected Management Frame configuration\nThe scan method to use when connecting to an AP\nSort by Security\nSort by signal strength (default)\nThis struct provides a safe wrapper over the ESP IDF Wifi …\nAssociation ID given by the AP\nthe aid that ESP32 soft-AP gives to the station connected …\nthe aid that ESP32 soft-AP gave to the station disconnects …\nReturns the underlying <code>EspNetif</code> for AP mode\nReturns the underlying <code>EspNetif</code> for AP mode, as mutable\nAuthentication method used for connecting to the AP\nBSSID (or MAC address) of the AP we connected to\nBSSID (or MAC address) of the AP we disconnected from\nBSSID of the target AP\nChannel used for the connection to the AP\nThe expected Channel of the target AP\nAs per <code>crate::sys::esp_wifi_connect</code>\nAs per <code>WifiDriver::connect()</code>\nAs per <code>WifiDriver::connect()</code>, but as a blocking call that …\nAs per <code>WifiDriver::connect()</code>, but as an async call that …\nAs per <code>crate::sys::esp_wifi_disconnect</code>\nAs per <code>WifiDriver::disconnect()</code>\nAs per <code>WifiDriver::disconnect()</code>, but as a blocking call …\nAs per <code>WifiDriver::disconnect()</code>, but as an async call that …\nReturns the underlying <code>WifiDriver</code>\nReturns the underlying <code>WifiDriver</code>, as mutable\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet information of AP which the ESP32 station is …\nReturns the set of [<code>Capabilities</code>] for this driver. In …\nAs per <code>WifiDriver::get_capabilities()</code>\nAs per <code>WifiDriver::get_capabilities()</code>\nAs per <code>WifiDriver::get_capabilities()</code>\nReturns the &lt;<code>Configuration</code>&gt; currently in use\nAs per <code>WifiDriver::get_configuration()</code>\nAs per <code>WifiDriver::get_configuration()</code>\nAs per <code>WifiDriver::get_configuration()</code>\nReturns the MAC address of the interface, as per …\nAs per <code>WifiDriver::get_mac()</code>.\nGet the results of an access point scan.\nAs per <code>WifiDriver::get_scan_result()</code>.\nGet the results of an access point scan.\nAs per <code>WifiDriver::get_scan_result_n()</code>.\nSequential identifier of the scan\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAs <code>BlockingWifi::wifi_wait_while()</code>, but for <code>EspWifi</code> events …\nAs <code>AsyncWifi::wifi_wait()</code>, but for <code>EspWifi</code> events related …\nReturns <code>true</code> if the driver is in Access Point (AP) mode, …\nAs per <code>WifiDriver::is_connected()</code>\nAs per <code>WifiDriver::is_connected()</code>\nAs per <code>WifiDriver::is_connected()</code>\nflag to identify mesh child\nflag to identify mesh child\nGets the state of the promiscuous mode for the <code>WifiDriver</code>.\nAs per <code>WifiDriver::is_scan_done()</code>\nReturns <code>true</code> if the driver is in Client (station or STA) …\nAs per <code>WifiDriver::is_started()</code>\nAs per <code>WifiDriver::is_started()</code>\nAs per <code>WifiDriver::is_started()</code>\nWhether this scan is a success or not\nReturns <code>true</code> when the driver has a connection, it has …\nAs per <code>EspWifi::is_up()</code>.\nAs per <code>EspWifi::is_up()</code>.\nNumber of scan results\nMAC address of the station connected to ESP32 soft-AP\nMAC address of the station disconnects to ESP32 soft-AP\nPMF configuration with PMF optional but available\nPMF configuration with PMF strictly required\nProtected Management Frame configuration\nThe reason for disconnection\nreason of disconnection\nRSSI at the time of disconnection\nScan for nearby, visible access points.\nAs per <code>WifiDriver::scan()</code>\nAs per <code>WifiDriver::scan()</code>\nAs per <code>WifiDriver::start_scan()</code> plus …\nThe scan method to use when searching for the target AP\nScan for nearby, visible access points.\nAs per <code>WifiDriver::scan_n()</code>\nAs per <code>WifiDriver::scan_n()</code>\nAs per <code>WifiDriver::start_scan()</code> plus …\nAs per <code>crate::sys::esp_wifi_internal_tx</code>\nSets callback functions for receiving and sending data, as …\nSets the &lt;<code>Configuration</code>&gt; (SSID, channel, etc). This also …\nAs per <code>WifiDriver::set_configuration()</code>\nAs per <code>WifiDriver::set_configuration()</code>\nAs per <code>WifiDriver::set_configuration()</code>\nSeta the MAC address of the interface, as per …\nAs per <code>WifiDriver::set_mac()</code>.\nSets callback functions for receiving and sending data, as …\nEnables or disables promiscuous mode for the <code>WifiDriver</code>.\nSet RSSI threshold below which APP will get an …\nSSID of the AP we connected to\nSSID of the AP we disconnected from\nSSID of the target AP\nReturns the underlying <code>EspNetif</code> for client mode\nReturns the underlying <code>EspNetif</code> for client mode, as mutable\nAs per <code>crate::sys::esp_wifi_start</code>\nAs per <code>WifiDriver::start()</code>\nAs per <code>WifiDriver::start()</code>, but as a blocking call that …\nAs per <code>WifiDriver::start()</code>, but as an async call that …\nStart scanning for nearby, visible access points.\nAs per <code>WifiDriver::start_scan()</code>.\nEnable and start WPS\nAs per <code>WifiDriver::start_wps()</code>\nStart WPS and perform a blocking wait until it connects, …\nStart WPS and perform a wait asynchronously until it …\nAs per <code>crate::sys::esp_wifi_stop</code>\nAs per <code>WifiDriver::stop()</code>\nAs per <code>WifiDriver::stop()</code>, but as a blocking call that …\nAs per <code>WifiDriver::stop()</code>, but as an async call that …\nStops a previous started access point scan.\nAs per <code>WifiDriver::stop_scan()</code>.\nReplaces the network interfaces with the given ones. …\nReplaces the AP network interface with the provided one …\nReplaces the STA network interface with the provided one …\nWaits until the underlaying network interface is up.\nWaits until the underlaying network interface is up.\nReturns the underlying <code>WifiDriver</code> or <code>EspWifi</code>\nReturns the underlying <code>WifiDriver</code> or <code>EspWifi</code>\nReturns the underlying <code>WifiDriver</code> or <code>EspWifi</code>, as mutable\nReturns the underlying <code>WifiDriver</code> or <code>EspWifi</code>, as mutable\nAwaits for a certain condition provided by the user in the …\nPerforms a blocking wait until certain condition provided …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")